#!python3
# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MarraquetaDialog
                                 A QGIS plugin
 Ponders different rasters with different utility functions
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-14
        git sha              : $Format:%H$
        copyright            : (C) 2024 by fdobad@github
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


from qgis.core import Qgis, QgsMessageLog
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtWidgets import (QCheckBox, QComboBox, QDialog,
                                 QDialogButtonBox, QGridLayout, QHBoxLayout,
                                 QLabel, QSlider, QSpinBox, QVBoxLayout)
from qgis.utils import iface


class MarraquetaDialog(QDialog):
    def __init__(self, parent=None):
        """Constructor."""
        super(MarraquetaDialog, self).__init__(parent)
        qprint("MarraquetaDialog.__init__")
        # set window title to Pan Europeo
        self.setWindowTitle("Pan Europeo (layer, weights, utility function)")
        self.verticalLayout = QVBoxLayout()
        self.setLayout(self.verticalLayout)

        # each row is a name | weight | resample | utility function
        self.grid = QGridLayout()
        self.grid.addWidget(QLabel("raster"), 0, 0)
        self.grid.addWidget(QLabel("weight"), 0, 1)
        self.grid.addWidget(QLabel("resample/interpolation algo."), 0, 2)
        self.grid.addWidget(QLabel("utility func."), 0, 3)

        # for each layer a row of controls
        self.rows = []
        for i, layer in enumerate(iface.mapCanvas().layers()):
            # name
            self.grid.addWidget(QLabel(layer.name()), i + 1, 0)
            # weight
            weight_layout = QHBoxLayout()
            checkbox = QCheckBox()
            spinbox = QSpinBox()
            slider = QSlider(Qt.Orientation.Horizontal)
            link_spinbox_slider_checkbox(spinbox, slider, checkbox)
            weight_layout.addWidget(checkbox)
            weight_layout.addWidget(spinbox)
            weight_layout.addWidget(slider)
            self.grid.addLayout(weight_layout, i + 1, 1)
            # resample
            resample_dropdown = QComboBox()
            # NO REORDER:
            resample_dropdown.addItems(
                ["Nearest Neighbor", "Bilinear", "Cubic", "Cubic Spline", "Lanczos", "Mode", "Average", "Gauss"]
            )
            resample_dropdown.row_id = i
            self.grid.addWidget(resample_dropdown, i + 1, 2)
            # utility function
            ufunc_layout = QHBoxLayout()
            ufunc_dropdown = QComboBox()
            # NO REORDER:
            ufunc_dropdown.addItems(["min-max", "bi-piecewise-linear"])
            # signal for hiding/showing each parameters
            ufunc_dropdown.currentIndexChanged.connect(self.function_change)
            # add id to the dropdown
            ufunc_dropdown.row_id = i
            ufunc_layout.addWidget(ufunc_dropdown)
            # minmax parameters
            cb = QCheckBox()
            cb.row_id = i
            cb.setText("Invert")
            cb.setChecked(False)
            cb.func_id = 0
            ufunc_layout.addWidget(cb)
            # piecewise-linear parameters
            # a
            a_spinbox = QSpinBox()
            a_slider = QSlider(Qt.Orientation.Horizontal)
            link_spinbox_slider(a_slider, a_spinbox)
            # b
            b_spinbox = QSpinBox()
            b_slider = QSlider(Qt.Orientation.Horizontal)
            link_spinbox_slider(b_slider, b_spinbox)
            for elto in [a_spinbox, a_slider, b_spinbox, b_slider]:
                elto.row_id = i
                elto.func_id = 1
                elto.setVisible(False)
                ufunc_layout.addWidget(elto)

            self.grid.addLayout(ufunc_layout, i + 1, 3)
            self.rows += [
                {
                    "i": len(self.rows),
                    "layer": layer,
                    "weight_checkbox": checkbox,
                    "weight_spinbox": spinbox,
                    "weight_slider": slider,
                    "resample_dropdown": resample_dropdown,
                    "ufunc_dropdown": ufunc_dropdown,
                    "minmax_invert": cb,
                    "a_spinbox": a_spinbox,
                    "a_slider": a_slider,
                    "b_spinbox": b_spinbox,
                    "b_slider": b_slider,
                }
            ]
        self.verticalLayout.addLayout(self.grid)

        # add a QtButtonBox to the bottom of the dialog with Ok, and Cancel
        self.buttonBox = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Close | QDialogButtonBox.Reset,
        )
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        for button in self.buttonBox.buttons():
            if button.text() == "Reset":
                button.clicked.connect(self.reset)

        self.verticalLayout.addWidget(self.buttonBox)
        # self.setupUi(self)

    def reject(self):
        self.destroy()

    def reset(self):
        self.destroy()
        self = self.__init__()

    def rescale_weights(self):
        """all inputs should sum to 100"""
        accum_weight = 0
        for row in self.rows:
            checkbox, spinbox = row["weight_checkbox"], row["weight_spinbox"]
            if checkbox.isChecked():
                accum_weight += spinbox.value()
        if accum_weight != 100 and accum_weight != 0:
            for row in self.rows:
                spinbox = row["weight_spinbox"]
                spinbox.setValue(int(spinbox.value() * 100 / accum_weight))

    def function_change(self, idx):
        """make visible row a_spinbox, a_slider, b_spinbox, b_slider if index !=0"""
        # def function_change(self, *args, **kwargs):
        # QgsMessageLog.logMessage(f"{args=}, {kwargs=}", "Marraqueta")
        # args=(1,), kwargs={}
        QgsMessageLog.logMessage(f"dropdown {idx=} {self.sender().row_id=}", "Marraqueta")
        # identify row
        row = self.rows[self.sender().row_id]
        # iterate over func_id elements
        for elto in row.values():
            if hasattr(elto, "func_id"):
                if elto.func_id == idx:
                    elto.setVisible(True)
                else:
                    elto.setVisible(False)


def link_spinbox_slider(slider, spinbox):
    """Link a QSpinBox, QSlider"""
    spinbox.setRange(0, 100)
    slider.setRange(0, 100)

    def set_spinbox_value(value):
        spinbox.setValue(value)

    def set_slider_value(value):
        slider.setValue(value)

    spinbox.valueChanged.connect(set_slider_value)
    slider.valueChanged.connect(set_spinbox_value)


def link_spinbox_slider_checkbox(spinbox, slider, checkbox):
    """Link a QSpinBox, QSlider and QCheckBox together."""
    spinbox.setRange(0, 100)
    slider.setRange(0, 100)
    link_spinbox_slider(slider, spinbox)

    def set_enabled(value):
        spinbox.setEnabled(value)
        slider.setEnabled(value)

    checkbox.stateChanged.connect(set_enabled)
    checkbox.setChecked(True)


def qprint(*args, tag="Marraqueta", level=Qgis.Info, sep=" ", end="\n", **kwargs):
    QgsMessageLog.logMessage(sep.join(map(str, args)) + end, tag, level, **kwargs)
